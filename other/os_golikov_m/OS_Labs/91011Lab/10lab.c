#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <wait.h>

#define CHILD_PROCESS 0
#define FORK_ERROR -1
#define EXEC_ERROR -1
#define WAIT_ERROR -1

/*
В данной программе используются следующие системные вызовы:

pid_t fork(void);
	1. Возвращает 0 в дочерний процесс и pid созданного процесса в родительский процесс, при ошибке возвращает (pid_t)-1 и устанавливает errno {
		- EAGAIN - недостаточно памяти или достигнут лимит процессов (для текущего пользователя или системный) для дублирования данного процесса
		- ENOMEM - недостаточно памяти в свопе
		- EPERM - у процесса нет прав на вызов fork()
	}
Системный вызов fork() создает новый процесс, который является дочерним по отношению к вызвавшему fork(). Адресное пространство нового процесса является полной копией родительского процесса, причем сегмент TEXT будет разделяемым, то есть одним и тем же физическим сегментом, отличить же дочерний процесс можно по pid (который не входит не в одну группу процессов) и по id родительского процесса. Отображения файлов в память сохраняются, если сегмент был отображен в режиме MAP_SHARED, то родительский и дочерний процессы используют один и тот же физический сегмент, если же MAP_PRIVATE или MAP_ANON, то они также используют одну и ту же физическую память, однако при первом обращении на запись этот сегмент копируется в адресное пространство записывающего процесса (copy-on-write). 
	
int execvp(const char *file, char *const argv[]);
	1. file - путь до файла программы
	2. argv - массив аргументов новой программы
	3. exec возвращает значение только в случае ошибки; возвращаемое значение -1 и устанавливается переменная errno {
		- E2BIG - размер массива аргументов превышает лимит
		- EACCES - нет прав на доступ к папке, содержащей этот файл, на исполнение этого файла или этот файл не является регулярным файлом
		- EAGAIN - временно недостаточно памяти на загрузку данной программы
		- EFAULT - аргументы указывают на неверный адрес
		- EINVAL - файл не является поддерживаемым исполняемым файлом
		- ENAMETOOLONG - длина пути файла превышает допустимую
		- ENOENT - файла по заданному пути не существует
	}
Системный вызов exec заменяет текущий образ процесса на новый, переданный аргументом file, с аргументами argv. Текст, данные, стек и остальные сегменты адресного пространства заменяют на соответствующие сегменты новой программы, однако пользовательская область сохраняется, то есть, например, файлы, открытые перед вызовом exec остаются открытыми, за исключением тех, у которых установлен флаг close-on-exec. Версии exec, которые не меняют среду, например execvp(), используют в качестве среды внешнюю переменную environ.
	
pid_t wait(int *stat_loc);
	1. stat_loc - статус выхода дочернего процесса
	2. Возвращает pid дочернего процесса, который завершился; при ошибке возвращает -1 и устанавливает errno {
		- ECHILD - у процесса нет дочерних процессов
	}
wait() останавливает выполнение данного процесса пока один из дочерних процессов не завершится. В stat_loc при этом будет записан аргумент завершения дочернего процесса (exit()). 

Макросы 
	1. WIFEXITED - не равно 0, если дочерний процесс завершился нормально
	2. WEXITSTATUS - возвращает статус выхода дочернего процесса
*/

int main(int argc, char **argv) {
	pid_t forkResult, error;
	int status;
	if(argc < 2) {
		printf("No arguments\nUsage: ./10run *program* *arguments*\n");
		return EXIT_SUCCESS;
	}
	forkResult = fork();
	if(forkResult == FORK_ERROR) {
		perror("Creating child process error");
		return EXIT_FAILURE;
	}
	if(forkResult == CHILD_PROCESS) {
		error = execvp(argv[1], &argv[1]);
		if(error == EXEC_ERROR) {
			perror("exec error");
			return EXIT_FAILURE;
		}
	}
	printf("Parent: waiting for child process with pid=%ld\n\n", forkResult);
	error = wait(&status);
	if(error == WAIT_ERROR) {
		perror("Wait error");
		return EXIT_FAILURE;
	}
	if(WIFEXITED(status)) printf("\nParent: child's status is %d\n", WEXITSTATUS(status));
	return EXIT_SUCCESS;
}
